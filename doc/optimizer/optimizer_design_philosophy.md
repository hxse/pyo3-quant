# 优化器设计理念

> **核心定位**：为高频回测提供极致并发的参数搜索能力，以时间换取暴力穷举的效率，拒绝复杂算法带来的顺序依赖。

---

## 1. 核心设计问题

在设计参数优化器时，我们必须回答一个根本问题：

**在有限的计算预算下，如何高效地找到全局最优参数？**

市面上有三种主流方案：

| 方案 | 原理 | 问题 |
|------|------|------|
| **贝叶斯优化** | 用代理模型预测好参数区域 | 顺序依赖，无法并行 |
| **遗传算法** | 模拟进化，交叉变异 | 代际同步，并行度受限 |
| **随机/网格搜索** | 暴力枚举 | 样本效率低，收敛慢 |

**本方案选择**：在随机搜索基础上加入**权重驱动**，兼取并行性和收敛性。

---

## 2. 为什么选择权重驱动随机搜索？

### 2.1 高并发优先

本项目的回测引擎速度极快（10,000 根 K 线 ~0.06 秒），意味着**样本效率不是瓶颈，吞吐量才是**。

贝叶斯优化的每次采样都依赖前一次结果，无法充分利用多核 CPU。遗传算法虽然支持并行，但"代际同步"限制了实际并发度。

权重驱动随机搜索的每个采样点**完全独立**，可以跑满 N 核，吞吐量线性扩展。

> **实测**：10,000 根 K 线 × 1,000 次迭代，Rust 优化器 ~1.2 秒，Optuna ~14.4 秒，**速度差 8.5 倍**。

### 2.2 算法简单可控

优化器本身的参数越多，越容易陷入"元优化"困境（需要调优化器的参数）。

本方案只暴露一个核心参数 `explore_ratio`（探索比例），其他参数均有合理默认值，用户无需费心。

### 2.3 天然支持向前滚动

向前滚动优化需要在窗口间传递"先验知识"（上一窗口的最优参数区域）。权重驱动机制天然支持这种继承——只需把上一窗口的 Top K 作为下一窗口的高斯核中心即可。

### 2.4 与回测引擎的零开销集成

本优化器与回测引擎深度集成，实现**零 Python 开销**：

*   **全 Rust 实现**：优化器核心逻辑、采样算法、并行调度全部在 Rust 层完成，没有任何 Python 代码参与热路径。
*   **共享数据结构**：优化器直接操作回测引擎的原生数据结构（`DataContainer`、`SingleParamSet`），无需序列化/反序列化。
*   **Rayon 并行**：使用 Rust 的 Rayon 库实现数据并行，自动利用所有 CPU 核心，无 GIL 锁竞争。
*   **内存零拷贝**：参数修改通过引用传递，避免不必要的内存分配。

这种设计使得优化器的性能瓶颈完全在回测计算本身，而非框架开销。

---

## 3. 算法原理

### 3.1 混合采样

每轮采样由两部分组成：

```
采样分布 = (1 - explore_ratio) × 权重驱动采样 + explore_ratio × LHS 全局采样
```

*   **权重驱动采样**：以历史 Top K 参数为中心，放置高斯核，按排名分配权重，聚焦最优区域。
*   **LHS 全局采样**：Latin Hypercube Sampling，均匀覆盖整个参数空间，防止陷入局部最优。

### 3.2 Sigma 衰减（搜索半径动态缩小）

高斯采样的标准差 σ 随迭代轮数衰减：

```rust
σ_current = σ_base / sqrt(round)
```

*   **初期**：搜索范围大，快速勘探全局。
*   **后期**：搜索范围小，精细开发最优区域。

### 3.4 持续探索（Persistent Exploration）

> **核心设计**：每轮迭代始终引入一定比例的全新参数，防止过早陷入局部最优。

无论当前的 Top K 多么集中，每轮都会有 `explore_ratio` 比例的采样点来自 **LHS 全局均匀分布**。这些新参数完全独立于历史最优，确保：

*   如果当前最优是局部最优，新探索点有机会发现更好的全局最优。
*   即使策略在某个区域完全失效，仍然能在其他区域找到有效参数。
*   避免算法过早收敛到“舒适区”后停滞不前。

这个设计在**向前滚动测试中自然复用**：即使继承了上一窗口的权重先验，新窗口仍然会引入新参数进行探索，避免“老参数传染”导致的渐进失效。

### 3.5 停止条件：Patience-Based

连续 `stop_patience` 轮（默认 10 轮）全局最优值没有创新高，则认为已收敛，自动停止。

---

## 4. 与其他方案对比

| 维度 | 本方案 | 贝叶斯 | 遗传 |
|------|--------|--------|------|
| **并发度** | ⭐⭐⭐ 极高 | ⭐ 低 | ⭐⭐ 中等 |
| **样本效率** | ⭐⭐ 中等 | ⭐⭐⭐ 高 | ⭐⭐ 中等 |
| **实现复杂度** | ⭐ 简单 | ⭐⭐⭐ 复杂 | ⭐⭐ 中等 |
| **窗口继承** | ⭐⭐⭐ 天然支持 | ⭐⭐ 可实现 | ⭐⭐ 可实现 |

---

## 5. 适用场景

*   **中短线策略**：参数生命周期短，需要频繁迭代优化。
*   **多参数优化**：5-20 个参数的中维搜索空间。
*   **向前滚动优化**：需要窗口间权重继承，防止过拟合。
*   **高频回测**：回测速度快，并发吞吐量是瓶颈而非样本效率。

---

## 6. 不适用场景

*   **长线持仓策略**：涉及跨窗口仓位继承，需要额外处理。
*   **高维灾难**：参数超过 50 维时，任何算法都会退化。
*   **极稀疏搜索预算**：只能评估 10-50 次时，贝叶斯优化更高效。

---

## 7. 设计哲学总结

1.  **并发压倒一切**：在现代多核 CPU 上，吞吐量比单次效率更重要。
2.  **简单即健壮**：算法越简单，越不容易出 Bug，越容易调试。
3.  **与交易哲学一致**：接受策略失效、动态迭代、追求效率。

本优化器不追求"完美的最优解"，而是在有限时间内找到"足够好的解"，并通过向前滚动验证其样本外稳健性。
