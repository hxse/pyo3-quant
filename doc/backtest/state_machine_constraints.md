# 单仓位回测状态机：约束与状态推断

本文档详细描述**单仓位回测引擎**状态机的核心设计原理。

## 系统特性

- **单仓位系统**：同一时刻只能持有一个方向的仓位（多头或空头），不支持同时持有多空
- **全仓模式**：每次开仓使用全部可用资金，无杠杆
- **价格驱动状态**：不使用显式 Position 枚举，而是通过价格字段组合推断状态

---

## 核心命题

> **数据清洗约束 + 运行时逻辑约束 = 可严格推断单 Bar 内所有仓位状态**

---

## 1. 术语区分

> ⚠️ **重要**：信号与价格是两个不同层次的概念，必须区分清楚。

| 层次 | 字段 | 类型 | 来源 |
|------|------|------|------|
| **信号层** | `entry_long`, `exit_long` | `bool` | 策略生成，经预处理清洗 |
| **价格层** | `entry_long_price`, `exit_long_price` | `Option<f64>` | 运行时根据信号+约束计算 |

- 信号是"意图"：策略**想要**做什么
- 价格是"结果"：引擎**实际执行**了什么

状态枚举基于**价格层**而非信号层。

---

## 2. 约束体系

### 2.1 数据清洗约束（预处理阶段）

在主循环执行前，通过 Polars Lazy API 对**信号**进行清洗。

| 规则 | 条件 | 处理 | 目的 |
|-----|------|------|------|
| R1 | `entry_long ∧ entry_short` | 两者都设为 `false` | 禁止同时进入多空 |
| R2 | `entry_long ∧ exit_long` | `entry_long = false` | 禁止进多同时平多 |
| R3 | `entry_short ∧ exit_short` | `entry_short = false` | 禁止进空同时平空 |
| R4 | `skip_mask = true` | 进场信号屏蔽 | 回撤暂停 |
| R5 | `atr = NaN` | 进场信号屏蔽 | ATR 无效保护 |

**输出保证**（以下信号组合被**拒绝**，不会出现）：
```
❌ entry_long ∧ entry_short   // 被 R1 拒绝
❌ entry_long ∧ exit_long     // 被 R2 拒绝
❌ entry_short ∧ exit_short   // 被 R3 拒绝
```

---

### 2.2 运行时逻辑约束（主循环阶段）

在 `BacktestState::calculate_position()` 中，代码逻辑隐含以下约束：

| 约束 | 相关方法/逻辑 | 效果 |
|------|-----------------|------|
| **价格重置** | `reset_long_state()` / `reset_short_state()` | 上一 bar 离场后重置对应方向价格，确保离场后可进入新仓位 |
| **进场需无仓位或反手** | `can_entry_long() = has_no_position() \|\| is_exiting_short()` | 禁止加仓、禁止同时持有多空 |
| **离场需持仓** | `has_long_position()` 时才设置 `exit_long_price` | 禁止对不存在的仓位离场 |
| **风控离场覆盖策略离场** | `!should_exit_in_bar_long()` 条件 | in_bar 已平仓则不再 next_bar 平仓 |
| **风控需持仓** | `check_risk_exit()` 仅在 `has_long_position()` 时调用 | 无仓位不触发风控 |

**推论**：
- `exit_long_price` 存在 → `entry_long_price` 必存在
- `exit_short_price` 存在 → `entry_short_price` 必存在
- 不可能同时持有多空仓位
- 持仓时忽略同向进场信号
- 无仓时忽略离场信号

### 2.3 执行顺序（关键设计）

> [!IMPORTANT]
> 同 bar 最复杂的场景是：先平仓（开盘价）→ 再反手开仓（开盘价）→ 再触发风控离场（SL/TP 价）
>
> 因此执行顺序必须是：**先离场 → 后进场 → 最后 risk**

```
1. 价格重置（上一 bar 离场完成后清理）
2. 策略离场检查（设置 exit_price）
3. 策略进场检查（此时 is_exiting_*() 可正确返回 true，支持反手）
4. Risk 离场检查（对新开仓位进行风控）
```

**为什么这个顺序是正确的**：

| 步骤 | 价格 | 说明 |
|------|------|------|
| 策略离场 | 开盘价 | 平掉上一根 K 线信号的仓位 |
| 策略进场 | 开盘价 | 按上一根 K 线信号反手开仓 |
| Risk 离场 | SL/TP 价 | 对新开仓位进行 in_bar 风控 |

这个顺序确保了 `can_entry_long()` 检查 `is_exiting_short()` 时，`exit_short_price` 已经被设置，从而正确触发反手逻辑。

---

## 3. 状态推断

### 3.1 有效状态白名单

经过约束过滤后，**只有以下 15 种状态是合法的**。任何不在此列表中的状态都是非法的，会在测试中验证。

> ⚠️ **白名单机制**：状态枚举表是**允许列表**，不在列表中的组合均为非法状态。

| # | entry_L | exit_L | entry_S | exit_S | in_bar | first_entry | 状态 |
|:-:|:-------:|:------:|:-------:|:------:|:------:|:-----------:|------|
| 1 | ✗ | ✗ | ✗ | ✗ | 0 | 0 | `no_position` |
| 2 | ✓ | ✗ | ✗ | ✗ | 0 | 0 | `hold_long` (延续) |
| 3 | ✓ | ✗ | ✗ | ✗ | 0 | 1 | `hold_long_first` (进场) |
| 4 | ✗ | ✗ | ✓ | ✗ | 0 | 0 | `hold_short` (延续) |
| 5 | ✗ | ✗ | ✓ | ✗ | 0 | -1 | `hold_short_first` (进场) |
| 6 | ✓ | ✓ | ✗ | ✗ | 0 | 0 | `exit_long_signal` |
| 7 | ✓ | ✓ | ✗ | ✗ | 1 | 0 | `exit_long_risk` (持仓后) |
| 8 | ✓ | ✓ | ✗ | ✗ | 1 | 1 | `exit_long_risk_first` (秒杀) |
| 9 | ✗ | ✗ | ✓ | ✓ | 0 | 0 | `exit_short_signal` |
| 10| ✗ | ✗ | ✓ | ✓ | -1 | 0 | `exit_short_risk` (持仓后) |
| 11| ✗ | ✗ | ✓ | ✓ | -1 | -1 | `exit_short_risk_first` (秒杀) |
| 12| ✓ | ✓ | ✓ | ✗ | 0 | -1 | `reversal_L_to_S` |
| 13| ✓ | ✗ | ✓ | ✓ | 0 | 1 | `reversal_S_to_L` |
| 14| ✓ | ✓ | ✓ | ✓ | 1 | 1 | `reversal_to_L_risk` |
| 15| ✓ | ✓ | ✓ | ✓ | -1 | -1 | `reversal_to_S_risk` |

### 3.2 被排除的组合（示例）

以下是部分被约束排除的组合示例。由于组合数量较多，无法完全列举，测试中使用白名单验证。

| 组合 | 排除原因 |
|------|----------|
| `(✓,✗,✓,✗)` | 同时持有多空，违反单仓位约束 |
| `(✗,✓,✗,✗)` | 孤立的 exit_long_price，无对应 entry |
| `(✗,✗,✗,✓)` | 孤立的 exit_short_price，无对应 entry |
| `(✗,✓,✗,✓)` | 两个孤立的 exit，无任何 entry |

---

## 4. 完备性论证

### 4.1 充分性

**给定任意有效的运行时状态，必然可以在白名单中找到唯一匹配。**

### 4.2 必要性

**白名单中的每个状态都是可达的。**

- 状态 1-3：初始状态或持仓状态
- 状态 4-7：策略或风控触发的离场
- 状态 8-9：反手进场
- 状态 10-11：反手后同 bar 风控离场

---

## 5. 设计决策

### 5.1 约束即契约

数据清洗不是可选的"优化"，而是状态机正确运行的**前置契约**。

### 5.2 状态即价格

传统回测使用显式 `Position` 枚举，本引擎使用**价格组合**推断状态。

> 💡 **设计动机**：
>
> 传统方案使用离散枚举（如 `Position::None | Long | Short`）表示仓位状态。但实践中发现，枚举与价格字段之间存在**状态同步问题**：
>
> 1. **冗余存储**：枚举是状态的"标签"，而 `entry_price`/`exit_price` 是状态的"数值"。两者必须同步更新，否则产生不一致。
> 2. **复杂边界**：在反手、风控触发等场景下，需要同时修改枚举和多个价格字段，极易遗漏。
> 3. **调试困难**：枚举无法直接输出到 DataFrame，需要额外转换；而价格字段天然可序列化。
>
> 本引擎采用**价格即状态**范式：完全移除 Position 枚举，通过价格字段组合推断状态。这实现了 **Single Source of Truth**（单一数据源），消除了状态同步的复杂性。

**优势**：
- **可审计**：DataFrame 输出即完整状态日志
- **无同步问题**：不存在枚举与价格不一致的 bug
- **调试友好**：直接查看价格列即可理解状态流转
- **测试简单**：只需验证每行状态是否在白名单内即可

### 5.3 `in_bar_direction` 与 `first_entry_side` 的必要性

- **`in_bar_direction`** (i8): 标记**离场**模式。0=Next-Bar, 1=多头In-Bar, -1=空头In-Bar。
- **`first_entry_side`** (i8): 标记**进场**模式。0=无进场, 1=多头进场, -1=空头进场。

**推断逻辑**：
- 用户通过 `exit_long_price` 且 `in_bar_direction == 1` 识别风控离场。
- 用户通过 `entry_long_price` 存在且 `first_entry_side == 1` 识别多头进场 Bar，无需使用 `shift(1)` 比较。
- **“秒杀”场景推断**（即进即出）：
  * 例如（多头）`first_entry_side == 1` 且 `in_bar_direction == 1`，同时 `entry_long_price` 和 `exit_long_price` 均存在时，表示发生了极端风控场景。

---

## 6. 总结

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   原始信号      │ ──▶ │   数据清洗      │ ──▶ │   无冲突信号    │
│  (可能冲突)     │     │  (拒绝非法组合) │     │                 │
└─────────────────┘     └─────────────────┘     └─────────────────┘
                                                        │
                                                        ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ 15 种合法状态   │ ◀── │   价格字段组合  │ ◀── │   运行时约束    │
│   (白名单)      │     │ + in_bar_dir    │     │ (仓位计算逻辑)  │
│                 │     │ + first_entry   │     │                 │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

**结论**：约束体系是状态机设计的基石。没有约束，就没有可靠的状态推断。
