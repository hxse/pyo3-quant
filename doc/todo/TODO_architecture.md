# 架构设计：双层仓位管理系统与极简主义原则

## 1. 核心设计哲学：拒绝复杂性 (Why Not VM?)

我们明确**放弃**之前的“交易专用状态机虚拟机 (VM)”方案。

### 为什么放弃 VM / 复杂设计？
1.  **代码品味 (Code Taste)**:
    *   **过度抽象是万恶之源**。构建一个 VM（指令集、内存布局、编译器）属于过度工程 (Over-engineering)。
    *   **调试噩梦**：当策略出错时，我们需要的是清晰的 Python/Rust 堆栈跟踪 (Stack Trace)，而不是 VM 内部晦涩的指令状态或寄存器值。
    *   **兼容层是垃圾**：我们不需要为了“通用性”构建中间层。如果接口不合适，直接进行破坏性更新 (Breaking Changes)。
2.  **直接性 (Directness)**:
    *   交易逻辑应该是**直观**的。`if price > sma` 比 `LOAD_VAR 0; CMP_GT` 更加直接和易于维护。
    *   Python 的灵活性加上 Rust 的性能已经足够，不需要发明第三种语言 (DSL)。
3.  **稳定性与健壮性**:
    *   每一层额外的抽象都会引入新的 BUG。
    *   使用 Pydantic 强类型约束不仅能保证数据正确，还能提供更好的 IDE 支持，比手写 VM 内存管理更靠谱。

---

## 2. 新架构：逐层扩展的单品种系统 (Single-Asset Architectures)

我们将通过两个阶段构建核心交易引擎。**注意：这两个阶段都属于“单品种系统”，即同一时刻只操作一个 Symbol（如 BTC/USDT）。**

### 第一阶段：单仓位系统 (Single Position System)
这是基础构建块，专注于**信号准确性**和**基础风控**。

*   **定义**：同一时间，针对同一品种，**只持有一个方向的一个仓位**。
*   **动作**：开多、开空、平仓、反手。
*   **入场/出场逻辑**:
    *   纯指标驱动 (Indicators: SMA, BBands, etc.)。
    *   严格的多周期数据支持 (Multi-timeframe Support)。
*   **基础风控 (Order Management)**:
    *   支持标准的 SL (Stop Loss), TP (Take Profit), TSL (Trailing Stop Loss)。
    *   所有的止损止盈逻辑在这一层经过严格测试，保证坚不可摧。
*   **实现细节**:
    *   利用 Pandas-TA/Rust TaLib 计算指标，确保数值精确对齐。

### 第二阶段：多仓位系统 (Multi-Position System)
这是对单仓位系统的**自然扩展**（Superset），依然作用于**单品种**。

*   **定义**：同一时间，针对同一品种，**可以持有多个同方向的子仓位**。
    *   **约束**：**严禁内部对冲 (No Hedging)**。所有持仓必须方向一致（全多或全空）。
    *   **用途**：用于金字塔加仓、网格交易、DCA (Dollar Cost Averaging) 等策略。
*   **逻辑复用**:
    *   **首个仓位 (Base Position)**: 完全复用“单仓位系统”的逻辑。即：使用相同的指标信号进行首次开仓。
*   **加仓逻辑 (Scaling In)**:
    *   **结构化配置 (Grid Layers)**: 采用 `Vec<GridLayer>` 的形式，将每层加仓的逻辑封装为独立对象，避免“平行数组”的维护地狱。
    *   **配置示例**:
        ```rust
        struct GridLayer {
            trigger_pnl_pct: f64, // -0.1 (跌10%触发)
            leverage: f64,        // 2.0 (本层使用2倍杠杆)
            stop_loss: f64,       // -0.05 (本层专属止损)
        }
        // 配置即为 Layers 列表
        let grids = vec![
            GridLayer { trigger_pnl_pct: -0.1, leverage: 1.0, stop_loss: -0.05 },
            GridLayer { trigger_pnl_pct: -0.2, leverage: 2.0, stop_loss: -0.05 },
        ];
        ```
    *   **增量扩展本质**:
        *   多仓位系统本质上只是在单仓位系统的基础上，**增加了一个 `grids` 配置参数**，并扩展了内部的 `positions` 列表状态。
        *   输出列从单一的 `entry_price` 扩展为 `average_price` 和 `positions_count`。
        *   除此之外，**核心逻辑与单仓位系统完全兼容**。它是单仓位系统的**超集 (Superset)**。
*   **独立风控**:
    *   **每个仓位独立管理**: 每一个加仓的子仓位 (Sub-position) 都拥有自己独立的 SL, TP, TSL 设置。
*   **即插即用**：在架构上，多仓位系统可以直接替代单仓位系统，对上层透明。

### 信号注入系统 (Signal Injection System)
为了统一支持单品种策略和多品种套利，我们引入**“外部信号注入”**机制，使基础仓位系统支持两种驱动模式。

*   **输入接口 (External Signal DataFrame)**:
    *   接收一个可选的 `Signal DataFrame`，包含以下列：
        *   `Entry_Long`, `Entry_Short`: 开仓信号。
        *   `Exit_Long`, `Exit_Short`: 平仓信号。
        *   `Change_Long`, `Change_Short`: **仓位变更信号** (Position Change)。
            *   **定义**：相对于**初始底仓 (Base Position)** 的倍数。
            *   `1.0`: 加仓 1 倍底仓。
            *   `-0.5`: 减仓 0.5 倍底仓。
            *   `0.0`: 无操作。
        *   `Skip_Open`: **禁止开仓信号** (1=Ban New Entry)。
        *   `Force_Close`: **强制平仓信号** (1=Panic Close)。

*   **逻辑覆盖规则 (Override/Partial Override)**:
    1.  **自动短路 (Auto-Bypass)**：
        *   若传入 `Entry_Long` 或 `Entry_Short`，则内部的指标开仓逻辑失效，改由外部信号驱动。
        *   若传入 `Change_Long` 或 `Change_Short`，则内部的 `GridLayers` 加仓配置失效，改由外部信号驱动。
        *   **混合驱动**：可以只注入 `Entry` 类信号（外部择时），但保留内部的 `GridLayers`（内部自动网格加仓）。
        *   **完全托管**：若注入所有信号，内部逻辑彻底失效，系统退化为纯执行器。
    2.  **风控兼容性 (Risk Control Compatibility)**:
        *   **原则**：外部信号仅覆盖**择时逻辑 (Timing)**，不覆盖**风控逻辑 (Risk)**。
        *   **SL/TP/TSL**: 即使注入了 `Exit_Long/Short` 信号，内部配置的硬性止损 (Stop Loss)、止盈 (Take Profit) 和追踪止损 (Trailing Stop) **依然生效**。
    3.  **附加过滤逻辑 (Overlay Filters)**:
        *   **特点**：**非短路**信号，叠加在所有逻辑之上。
        *   `Skip_Open`: **禁止开仓信号** (1=Ban New Entry)。
            *   **用途**：宏观风险极大时（如 CPI 发布前），禁止开新仓，但允许现有仓位运行或平仓。
            *   **逻辑**：`if Skip_Open == 1: Block All Entry/Add Signals`。
        *   `Force_Close`: **强制平仓信号** (1=Panic Close)。
            *   **用途**：当本金回撤达到熔断线（如 -10%）或出现黑天鹅时，强制清空所有头寸。
            *   **逻辑**：`if Force_Close == 1: Close All Positions Immediately`。

### 关于“单品种对冲”的特别说明 (No Hedging Policy)
我们**坚决拒绝**在单品种系统内部支持“同时持有多空双向仓位” (Hedging Mode)。
*   **不仅不优雅，而且愚蠢**：
    *   **资金效率低**：占用双倍保证金，支付双倍交易手续费，承受双向资金费率风险。
    *   **架构污染**：单品种内搞对冲是典型的**伪需求**，会让架构变得极脏。
*   **正确做法**：
    *   **拥抱套利 (Arbitrage)**：如果想要真正的对冲，应该去寻找**相关性高的另一个品种**做配对交易，而非在同一品种上左右互搏。
    *   **网格代替震荡对冲**：震荡市的所谓“对冲”需求，可以用单向的多仓位网格 (Grid) 替代。
    *   **Keep Internal Logic Pure**: 单品种系统永远只维护净头寸 (Net Position)。

---

## 3. 总结

新的架构不再追求构建一个“全能机器”，而是追求**解决特定的交易问题**。

*   **Old Way (VM)**: 试图预测所有可能的策略逻辑，构建复杂的解释器。 -> **Rejected**
*   **New Way (Layered)**:
    1.  把单次交易 (Entry/Exit/SL/TP) 做到极致稳定。
    2.  通过管理浮盈和仓位列表来实现复杂策略 (Grid/Pyramid)。

Keep it simple, keep it robust, keep it pro.

---

## 4. 扩展性视角：多品种系统 (Multi-Asset System)

**套利 (Arbitrage) 和 投资组合 (Portfolio) 属于“多品种系统”。** 它们并不关心底层的“单品种系统”是用单仓位还是多仓位实现的，只关心**接口统一**和**杠杆统一**。

### 4.1 本质回归 (Back to Basics)
*   **套利 (Arbitrage) = 两个“单品种系统”的并行**
    *   **核心思想**：所有的套利逻辑（配对、相关性、价差、止损）都在**数据预处理阶段 (Data Preprocessing)** 完成，计算出明确的 `Entry_Signal` 和 `Exit_Signal`，然后喂给底层系统执行。
    *   **底层兼容性**：底层可以是“单仓位系统”（简单套利），也可以是“多仓位系统”（例如：触发套利信号后，分批金字塔建仓）。
    *   **进场信号算法 (Entry Signal)**：
        1.  **滤网 (Correlation Filter)**：计算滚动窗口 (e.g., N=1H) 的相关系数。
            *   `Corr = Rolling_Corr(Return_A, Return_B, Window)`
            *   **条件**：`Corr > 0.8` (仅在强相关时操作)。
        2.  **触发 (Z-Score Trigger)**：计算价差 (`Ratio = Price_A / Price_B`) 的布林带标准化偏离。
            *   `Mean = Rolling_Mean(Ratio, Window)`
            *   `Std = Rolling_Std(Ratio, Window)`
            *   `Z_Score = (Ratio - Mean) / Std`
            *   **开空价差 (Short Spread)**：`Z_Score > 2.0` (做空 A，做多 B)。
            *   **开多价差 (Long Spread)**：`Z_Score < -2.0` (做多 A，做空 B)。

    *   **离场信号算法 (Exit Signal)**：
        1.  **止盈 (Profit Taking)**：价差回归均值。
            *   **条件**：`abs(Z_Score) < 0.2` (或回归到 0)。
        2.  **矢量化强平 (Vectorized Stop Loss)**：基于 Polars 的**无状态**预计算。
            *   **原理**：利用 `forward_fill` 极其高效地获取每一时刻的持仓成本，无需逐行回测。
            *   **步骤 1 (标记开仓价)**：`Entry_Price_A = when(Entry_Signal).then(Price_A).otherwise(null).forward_fill()`
            *   **步骤 2 (计算浮盈)**：`PnL_A_Pct = (Price_A / Entry_Price_A) - 1` (做多) 或 `1 - (Price_A / Entry_Price_A)` (做空)。同理计算 B。
            *   **步骤 3 (组合监控)**：`Total_PnL = (PnL_A_Pct + PnL_B_Pct) / 2 * Leverage`
            *   **条件**：`Total_PnL < -10%`。一旦触发，强制将该时间点的信号置为 `Force_Exit`。

    *   **优势**：
        *   **零延迟**：所有信号在进入回测循环前已计算完毕（Polars 矢量化）。
        *   **双重保险**：既有统计层面的回归止盈，又有资金层面的硬性止损。
        *   **零修改**：单仓位系统只负责执行信号，完全解耦。

*   **投资组合 (Portfolio) = 资金曲线叠加 + 动态权重管理**
    *   **基础模式 (Static)**：直接并发运行 N 个独立的单仓位/多仓位系统，在 Python 层叠加资金曲线。
    *   **进阶模式 (Dynamic Weighting via Signal Injection)**：
        *   **场景**：基于滚动窗口 (Rolling Window) 的相关性分析或风险平价 (Risk Parity) 模型，**每月/每周动态调整各策略的权重**。
        *   **实现**：利用 **“外部信号注入”** 机制。
            *   计算出策略 A 在下个月的目标权重（例如从 1.0 降至 0.8）。
            *   生成对应的 `Change_Long` 信号（例如 `-0.2`），注入到策略 A 的信号列中。
            *   策略 A 会在指定时间点自动减仓，实现**动态再平衡 (Rebalancing)**。
        *   **宏观风控**：利用 `Skip_Open` 或 `Force_Close` 信号，在宏观风险极高时（如 VIX 爆表）统一暂停或清空整个组合。
        *   **一致性保证**：此模式确保了**回测与实盘逻辑的完美统一**。
            *   回测时：按月滚动计算信号并注入，模拟真实世界的信息流。
            *   实盘时：每月底运行同样的 Python 脚本生成新的权重指令，发给策略执行。
            *   完全消除了“上帝视角”和“过拟合”风险。

### 4.2 杠杆管理的挑战与方案
在多品种/多策略组合中，杠杆管理至关重要。如果我们允许每个单策略随意使用不同杠杆，组合后的风险将不可控。我们倾向于**外部统一杠杆**。

**极简方案：最大杠杆对齐 + 资金自动平分**
1.  **策略级约束**：每个独立策略（无论是单仓位还是多仓位）都必须强制声明其 `Max_Leverage` (最大杠杆)。策略内部可自主在 `[1, Max_Leverage]` 范围内调整即时杠杆，但无法超过最大杠杆。
2.  **组合性强制校验 (Unified Max Leverage)**：在启动投资组合或套利策略时，系统执行严格校验：**所有参与子策略的 `Max_Leverage` 必须完全一致**。若检测到不一致，系统直接报错并拒绝运行。
3.  **自然平均分配**：在“最大杠杆一致”的前提下，投资组合对各品种**平均分配资金**。这自然而然地实现了每个策略潜在最大资金使用量的一一对应和全局风险的统一量化。
4.  **全局风控一致性**：由于杠杆上限和本金分配双重归一化，账户级的止损和风控逻辑变得极其简单且健壮。

**结论**：
无论哪种方案，核心原则是 **Global Leverage Control (全局杠杆把控)**。单策略可以有战术上的杠杆调整，但在战略层面上必须服从组合的统一配置。

---

## 6. 当前实施状态与优先级 (Implementation Status & Priorities)

> **本节说明上述架构的哪些部分已实现，哪些部分暂缓，以及背后的决策逻辑。**

### 6.1 已完成：单仓位系统 ✅

**状态**：Production Ready，经过与 backtesting.py 的相关性验证。

**功能覆盖**：
- 多周期数据支持（15m/1h/4h）
- 完整的 SL/TP/TSL 风控
- 信号清洗规则（R1-R5）
- 跳空保护、ATR 计算
- 与 backtesting.py 相关性分析（equity_r > 0.85，详见 `py_entry/Test/backtest/correlation_analysis/test_correlation.py`）

**满足需求**：
- 趋势跟踪策略（三重滤网）
- 均值回归策略（BBands/RSI）
- 符合当前交易哲学（高杠杆、短生命周期）

---

### 6.2 暂缓：多仓位系统 ⏸️

> **技术设计已完成**（详见 `doc/todo/TODO_multi_position_system.md`），但决定**暂缓实施**。

#### 暂缓理由 1：与交易哲学冲突

当前交易哲学：`小资金 × 高杠杆 × 短生命周期策略 × Calmar → MaxSafeLeverage`

```
MaxSafeLeverage = SafetyFactor / MDD
```

**问题**：加仓（DCA/Grid/Pyramiding）必然增大 MDD，直接降低安全杠杆倍数。

| MDD | SafetyFactor=0.8 时的杠杆 | 年化收益（假设原始 10%） |
|:---:|:-----------------------:|:--------------------:|
| 10% | 8x | 80% |
| 15% | 5.3x | 53% |
| 20% | 4x | 40% |

- **高杠杆已经用 `SafetyFactor / MDD` 杠到极限**，没有多余 margin 给加仓
- **DCA/Grid/Pyramiding 本质是防守策略**，适合大资金、低杠杆、长周期持仓
- **15m/1h 波段策略持仓周期短**，没有"逢低加仓"的时间窗口
- 详见 `doc/trading_philosophy/quantitative_trading.md`

#### 暂缓理由 2：无法进行相关性验证

当前系统的可信度建立在与 backtesting.py 的**相关性分析**之上。

**验证困境**：
- backtesting.py **不支持多仓位**，无法作为对标引擎
- 没有第三方引擎可用于交叉验证
- 自己测自己 = 没有外部参照 = 无法确信引擎正确性
- 破坏性更新（直接替代单仓位）意味着废弃已验证的系统，如果新引擎有 bug，没有退路

#### 暂缓理由 3：无强刚需

当前场景下的替代方案：
- **趋势加仓**：单仓位 + TSL 已经足够捕捉趋势并保护利润
- **震荡网格**：单仓位均值回归策略可覆盖，或用行情过滤器直接规避震荡市
- **逢低定投**：长线策略，手动交易可替代
- **套利需求**：本质是多资产协调，不是多仓位（见下文）

#### 启动前提条件

1. **找到支持多仓位的第三方回测引擎**用于相关性验证
2. **出现明确的策略需求**，且该策略无法用单仓位 + 信号注入替代
3. **单仓位系统已完全稳定**，有充足精力投入重写

---

### 6.3 暂缓：投资组合 (Portfolio) ⏸️

> **投资组合是为大资金防守设计的，不适合小资金进攻。**

#### 核心问题：分散效果极其有限

```
组合 MDD ≈ 单策略 MDD × √(1/N + (1-1/N) × ρ)
```

**加密市场相关性高达 0.85+**（BTC 打喷嚏全市场感冒）：

| 策略数 | 相关性 ρ=0 | 相关性 ρ=0.85 |
|:-----:|:---------:|:------------:|
| 3 个策略 | MDD × 0.58 | MDD × 0.93 |

**实际效果只有 7% 的 MDD 降幅**，远不如深研单策略。

#### 深研策略 vs 投资组合

```
方案 A：深研 1 个策略
  投入：100% 研发精力
  MDD：10%
  Leverage：8x
  Return：80%

方案 B：开发 3 个策略做组合
  投入：每个策略 33% 精力 → 每个策略质量更低
  单策略 MDD：15%（研发不够深入）
  组合 MDD：15% × 0.93 = 14%
  Leverage：5.7x
  Return：57%
```

**结论**：深研 1 个策略 >>> 草草搞 3 个策略做组合。

#### Calmar 提升靠什么？

- **不是靠分散**（加密市场相关性太高）
- **是靠更好的行情过滤器和更精细的风控**
- **这些都需要深研单策略**

#### 当前资金规模不需要

- 初始资金 3000 元，拆成 3 份太小
- 等资金翻几倍后，单策略容量不够时再考虑

---

### 6.4 暂缓：套利策略 (Arbitrage) ⏸️

> **散户做不了套利。不是能力问题，是手续费结构决定的。**

#### 手续费数学：双腿吃掉所有利润

| 项目 | 单资产策略 | 配对套利 |
|------|----------|---------|
| 开仓手续费 | 0.05% × 1 = 0.05% | 0.05% × 2 = 0.10% |
| 平仓手续费 | 0.05% × 1 = 0.05% | 0.05% × 2 = 0.10% |
| **往返总费** | **0.10%** | **0.20%** |

**1h 配对交易期望收益计算**：
```
价差波动：±1.0%
胜率：60%
期望收益 = 60% × (1.0% - 0.20%) - 40% × (1.0% + 0.20%)
         = 0.48% - 0.48%
         ≈ 0%
```

**手续费直接把期望收益降到零。**

#### 各周期套利可行性

| 周期 | 散户能做吗 | 原因 |
|:---:|:---------:|------|
| 1s-1m | ❌ 绝对不行 | 网速、Co-location，完全被碾压 |
| 5m-15m | ❌ 不行 | 手续费吃掉所有利润 |
| 30m-1h | ❌ 不行 | 手续费占比仍然太高，期望收益 ≈ 0 |
| 4h-1d | ⚠️ 勉强可以 | MDD 上升到跟单资产差不多，Calmar 不比单资产好 |

#### 机构为什么能做

- Maker 费率 0.01% 甚至负费率（交易所倒贴）
- VIP 阶梯 0.02%
- **散户的 0.05% 是机构的 2.5-5 倍**

这个差距直接决定了盈亏分界线。

---

### 6.5 最高优先级：行情过滤器 (Regime Filter) 🔥

> **这才是降低 MDD 的真正杀手。**

#### 核心洞察

**散户 MDD 的主要来源不是信号不准，而是在震荡市里被反复打止损。**

行情过滤器（赫斯特指数/KAMA）让策略在震荡市"闭嘴"：

| 场景 | MDD | Leverage | 年化（假设原始 10%） |
|------|:---:|:--------:|:-------------------:|
| 无过滤器 | 15% | 5.3x | 53% |
| 加行情过滤器 | 8% | 10x | 100% |

**MDD 从 15% 降到 8%，杠杆从 5x 跳到 10x。这比任何套利策略都强。**

#### 你自己写的交易哲学

> "赫斯特指数 (Hurst Exponent)：判断市场是趋势、随机还是均值回归"
> "考夫曼自适应过滤器 (KAMA)：根据市场噪音自动调整灵敏度"
> "效果显著：实战经验表明，高级数学过滤器的效果**远好于传统 ADX 指标**"

详见 `doc/trading_philosophy/quantitative_trading.md`，第 2.3 节。

#### 为什么是最高 ROI

- **无需新基础设施**：现有 SignalTemplate 体系直接支持
- **不破坏现有系统**：行情过滤器只是新增一列数据用于过滤信号
- **直接服务于核心目标**：降 MDD → 提高杠杆 → 最大化收益
- **可立即验证**：通过 backtesting.py 相关性分析验证效果

---

### 6.6 优先级排序总结

| 优先级 | 功能 | 状态 | ROI | 理由 |
|:-----:|------|:----:|:---:|------|
| P0 | **行情过滤器** | 🔥 最高 | 极高 | 直接降 MDD，提升杠杆，已有基础设施 |
| P1 | 均值回归策略 | 中 | 高 | 与趋势互补，系统已支持"单体多模式" |
| P2 | 策略组合（同策略跑多品种） | 低 | 中 | 适度分散，但收益有限（~7%） |
| - | 多仓位系统 | ⏸️ 暂缓 | 低 | 哲学冲突，无验证手段，无刚需 |
| - | 投资组合 | ⏸️ 暂缓 | 低 | 大资金防守工具，不适合小资金进攻 |
| - | 配对套利 | ⏸️ 暂缓 | 负 | 手续费吃掉利润，期望收益 ≈ 0 |

**一句话：专注于让现有趋势策略在震荡市里"闭嘴"。这才是你的最优路径。**
