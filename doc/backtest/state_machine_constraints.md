# 单仓位回测状态机：约束与状态推断

本文档详细描述**单仓位回测引擎**状态机的核心设计原理。

## 系统特性

- **单仓位系统**：同一时刻只能持有一个方向的仓位（多头或空头），不支持同时持有多空
- **全仓模式**：每次开仓使用全部可用资金，无杠杆
- **价格驱动状态**：不使用显式 Position 枚举，而是通过价格字段组合推断状态

---

## 核心命题

> **数据清洗约束 + 运行时逻辑约束 = 可严格推断单 Bar 内所有仓位状态**

---

## 1. 术语区分

> ⚠️ **重要**：信号与价格是两个不同层次的概念，必须区分清楚。

| 层次 | 字段 | 类型 | 来源 |
|------|------|------|------|
| **信号层** | `enter_long`, `exit_long` | `bool` | 策略生成，经预处理清洗 |
| **价格层** | `entry_long_price`, `exit_long_price` | `Option<f64>` | 运行时根据信号+约束计算 |

- 信号是"意图"：策略**想要**做什么
- 价格是"结果"：引擎**实际执行**了什么

状态枚举基于**价格层**而非信号层。

---

## 2. 约束体系

### 2.1 数据清洗约束（预处理阶段）

在主循环执行前，通过 Polars Lazy API 对**信号**进行清洗。

| 规则 | 条件 | 处理 | 目的 |
|-----|------|------|------|
| R1 | `enter_long ∧ enter_short` | 两者都设为 `false` | 禁止同时进入多空 |
| R2 | `enter_long ∧ exit_long` | `enter_long = false` | 禁止进多同时平多 |
| R3 | `enter_short ∧ exit_short` | `enter_short = false` | 禁止进空同时平空 |
| R4 | `skip_mask = true` | 进场信号屏蔽 | 回撤暂停 |
| R5 | `atr = NaN` | 进场信号屏蔽 | ATR 无效保护 |

**输出保证**（以下信号组合被**拒绝**，不会出现）：
```
❌ enter_long ∧ enter_short   // 被 R1 拒绝
❌ enter_long ∧ exit_long     // 被 R2 拒绝
❌ enter_short ∧ exit_short   // 被 R3 拒绝
```

---

### 2.2 运行时逻辑约束（主循环阶段）

在 `calculate_position()` 中，代码逻辑隐含以下约束：

| 约束 | 代码位置 | 逻辑 | 效果 |
|------|----------|------|------|
| **价格重置** | L20-32 | 上一 bar 离场后重置对应方向价格 | 确保离场后可进入新仓位 |
| **进场需无仓位或反手** | L41,45 | `can_enter_long() = has_no_position() \|\| is_exiting_short()` | 禁止加仓、禁止同时持有多空 |
| **离场需持仓** | L51,57 | `has_long_position()` 时才设置 `exit_long_price` | 禁止对不存在的仓位离场 |
| **风控离场覆盖策略离场** | L53,59 | `!should_exit_in_bar_long()` 条件 | in_bar 已平仓则不再 next_bar 平仓 |
| **风控需持仓** | L68,75 | `has_long_position()` 时才检查风控 | 无仓位不触发风控 |

**推论**：
- `exit_long_price` 存在 → `entry_long_price` 必存在
- `exit_short_price` 存在 → `entry_short_price` 必存在
- 不可能同时持有多空仓位
- 持仓时忽略同向进场信号
- 无仓时忽略离场信号

### 2.3 执行顺序（关键设计）

> [!IMPORTANT]
> 同 bar 最复杂的场景是：先平仓（开盘价）→ 再反手开仓（开盘价）→ 再触发风控离场（SL/TP 价）
>
> 因此执行顺序必须是：**先离场 → 后进场 → 最后 risk**

```
1. 价格重置（上一 bar 离场完成后清理）
2. 策略离场检查（设置 exit_price）
3. 策略进场检查（此时 is_exiting_*() 可正确返回 true，支持反手）
4. Risk 离场检查（对新开仓位进行风控）
```

**为什么这个顺序是正确的**：

| 步骤 | 价格 | 说明 |
|------|------|------|
| 策略离场 | 开盘价 | 平掉上一根 K 线信号的仓位 |
| 策略进场 | 开盘价 | 按上一根 K 线信号反手开仓 |
| Risk 离场 | SL/TP 价 | 对新开仓位进行 in_bar 风控 |

这个顺序确保了 `can_enter_long()` 检查 `is_exiting_short()` 时，`exit_short_price` 已经被设置，从而正确触发反手逻辑。

---

## 3. 状态推断

### 3.1 有效状态白名单

经过约束过滤后，**只有以下 11 种状态是合法的**。任何不在此列表中的状态都是非法的，会在测试中验证。

> ⚠️ **白名单机制**：状态枚举表是**允许列表**，不在列表中的组合均为非法状态。

| # | entry_long_price | exit_long_price | entry_short_price | exit_short_price | in_bar_direction | 状态 |
|:-:|:----------------:|:---------------:|:-----------------:|:----------------:|:----------------:|------|
| 1 | ✗ | ✗ | ✗ | ✗ | 0 | `no_position` |
| 2 | ✓ | ✗ | ✗ | ✗ | 0 | `hold_long` |
| 3 | ✗ | ✗ | ✓ | ✗ | 0 | `hold_short` |
| 4 | ✓ | ✓ | ✗ | ✗ | 0 | `exit_long_signal` |
| 5 | ✓ | ✓ | ✗ | ✗ | 1 | `exit_long_risk` |
| 6 | ✗ | ✗ | ✓ | ✓ | 0 | `exit_short_signal` |
| 7 | ✗ | ✗ | ✓ | ✓ | -1 | `exit_short_risk` |
| 8 | ✓ | ✓ | ✓ | ✗ | 0 | `reversal_long_to_short` |
| 9 | ✓ | ✗ | ✓ | ✓ | 0 | `reversal_short_to_long` |
| 10 | ✓ | ✓ | ✓ | ✓ | 1 | `reversal_to_long_then_exit` |
| 11 | ✓ | ✓ | ✓ | ✓ | -1 | `reversal_to_short_then_exit` |

### 3.2 被排除的组合（示例）

以下是部分被约束排除的组合示例。由于组合数量较多，无法完全列举，测试中使用白名单验证。

| 组合 | 排除原因 |
|------|----------|
| `(✓,✗,✓,✗)` | 同时持有多空，违反单仓位约束 |
| `(✗,✓,✗,✗)` | 孤立的 exit_long_price，无对应 entry |
| `(✗,✗,✗,✓)` | 孤立的 exit_short_price，无对应 entry |
| `(✗,✓,✗,✓)` | 两个孤立的 exit，无任何 entry |

---

## 4. 完备性论证

### 4.1 充分性

**给定任意有效的运行时状态，必然可以在白名单中找到唯一匹配。**

### 4.2 必要性

**白名单中的每个状态都是可达的。**

- 状态 1-3：初始状态或持仓状态
- 状态 4-7：策略或风控触发的离场
- 状态 8-9：反手进场
- 状态 10-11：反手后同 bar 风控离场

---

## 5. 设计决策

### 5.1 约束即契约

数据清洗不是可选的"优化"，而是状态机正确运行的**前置契约**。

### 5.2 状态即价格

传统回测使用显式 `Position` 枚举，本引擎使用**价格组合**推断状态。

> 💡 **设计动机**：
>
> 传统方案使用离散枚举（如 `Position::None | Long | Short`）表示仓位状态。但实践中发现，枚举与价格字段之间存在**状态同步问题**：
>
> 1. **冗余存储**：枚举是状态的"标签"，而 `entry_price`/`exit_price` 是状态的"数值"。两者必须同步更新，否则产生不一致。
> 2. **复杂边界**：在反手、风控触发等场景下，需要同时修改枚举和多个价格字段，极易遗漏。
> 3. **调试困难**：枚举无法直接输出到 DataFrame，需要额外转换；而价格字段天然可序列化。
>
> 本引擎采用**价格即状态**范式：完全移除 Position 枚举，通过价格字段组合推断状态。这实现了 **Single Source of Truth**（单一数据源），消除了状态同步的复杂性。

**优势**：
- **可审计**：DataFrame 输出即完整状态日志
- **无同步问题**：不存在枚举与价格不一致的 bug
- **调试友好**：直接查看价格列即可理解状态流转
- **测试简单**：只需验证每行状态是否在白名单内即可

### 5.3 `in_bar_direction` 的必要性

`in_bar_direction` (i8) 的作用：
- `0`：策略信号触发（Next Bar 模式）
- `1`：多头风控触发（In Bar 模式）
- `-1`：空头风控触发（In Bar 模式）

**推断逻辑**：用户通过 `exit_long_price` 且 `in_bar_direction == 1`（或 short 对应 -1）即可识别风控离场，无需冗余列。

---

## 6. 总结

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   原始信号      │ ──▶ │   数据清洗      │ ──▶ │   无冲突信号    │
│  (可能冲突)     │     │  (拒绝非法组合) │     │                 │
└─────────────────┘     └─────────────────┘     └─────────────────┘
                                                        │
                                                        ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ 11 种合法状态   │ ◀── │   价格字段组合  │ ◀── │   运行时约束    │
│   (白名单)      │     │ + in_bar_dir    │     │ (仓位计算逻辑)  │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

**结论**：约束体系是状态机设计的基石。没有约束，就没有可靠的状态推断。
